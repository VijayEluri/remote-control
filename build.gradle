buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath "org.gebish:markdown2book:1.0",
                "org.apache.maven.wagon:wagon-webdav-jackrabbit:1.0-beta-6"
    }
}

allprojects {
    version = '0.6-SNAPSHOT'
    group = 'org.codehaus.groovy.modules.remote'

    ext {
        isSnapshot = version.endsWith("SNAPSHOT")
        groovyVersion = "2.0.6"
        spockVersion = "0.7-groovy-2.0"

        spockDependency = "org.spockframework:spock-core:$spockVersion"
        groovyDependency = "org.codehaus.groovy:groovy-all:$groovyVersion"
    }

    repositories {
        mavenCentral()
    }

    apply plugin: "idea"
}
apply from: "$rootDir/gradle/idea.gradle"

def groovyModules = [
        ":module:remote-core", ":module:remote-transport-local", ":module:remote-transport-http", ":module:remote-test-utils"
]

def publishedModules = [
        ":module:remote-core", ":module:remote-transport-local", ":module:remote-transport-http"
]

def publishedGroovyModules = groovyModules.findAll { it in publishedModules }

subprojects {
    if (project.path in groovyModules) {
        apply plugin: "groovy"
        apply plugin: "codenarc"

        codenarc {
            configFile = rootProject.file("config/codenarc/codenarc.xml")
        }

        dependencies {
            groovy groovyDependency
            testCompile spockDependency
        }

        sourceCompatibility = 1.5
        targetCompatibility = 1.5
    }

    if (project.path in publishedModules) {
        apply plugin: 'maven'
        apply from: "$rootDir/gradle/pom.gradle"
        apply plugin: 'signing'

        task sourcesJar(type: Jar, dependsOn: classes) {
            classifier = 'sources'
            from sourceSets.main.allSource
        }

        task javadocJar(type: Jar, dependsOn: javadoc) {
            classifier = 'javadoc'
            from javadoc.destinationDir
        }

        signing {
            sign configurations.archives
            required { !isSnapshot && gradle.taskGraph.hasTask(uploadArchives) }
        }

        configurations {
            deployerJars
            archives.extendsFrom signatures
        }

        artifacts {
            archives javadocJar
            archives sourcesJar
        }

        uploadArchives { task ->
            repositories.mavenDeployer {
                beforeDeployment { MavenDeployment deployment ->
                    signing.signPom(deployment)
                }
                gradle.taskGraph.whenReady { taskGraph ->
                    if (taskGraph.hasTask(task)) {
                        repository(url: "https://nexus.codehaus.org/service/local/staging/deploy/maven2/") {
                            authentication(userName: codehausUsername, password: codehausPassword)
                        }
                        snapshotRepository(url: "https://nexus.codehaus.org/content/repositories/snapshots/") {
                            authentication(userName: codehausUsername, password: codehausPassword)
                        }
                    }
                }
            }
        }

        modifyPom { pom ->
            pom.dependencies.removeAll(pom.dependencies.findAll { it.scope == "test" })

            pom.project {
                name project.name
                description project.description
                if (description == null) {
                    throw new InvalidUserDataException("Project '$project' has no description")
                }
                url "http://groovy.codehaus.org/modules/remote"
                inceptionYear "2010"
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
                scm {
                    url "https://github.com/alkemist/groovy-remote"
                }
                developers {
                    developer {
                        id "ldaley"
                        name "Luke Daley"
                        roles {
                            role "Lead"
                            role "Founder"
                        }
                    }
                }
            }
        }
    }
}

project(':module:remote-core') {
    description "Provides the core of the remote library"
    dependencies {
        testCompile project(":module:remote-transport-local"), project(":module:remote-using-lib"),
                project(":module:remote-test-utils")
    }
}

project(':module:remote-transport-http') {
    description "Support for sending and receiving remote commands over HTTP (including a servlet implementation)"
    dependencies {
        compile project(":module:remote-core"),
                "javax.servlet:servlet-api:2.4"
        testCompile "org.mortbay.jetty:jetty:6.1.21"
    }
}

project(':module:remote-transport-local') {
    description "Provides an in process bridge for sending/receiving commands"
    dependencies {
        compile project(":module:remote-core")
    }
}

project(':module:remote-using-lib') {
    apply plugin: "groovy"

    dependencies {
        groovy groovyDependency
        compile project(":module:remote-core")
    }
}

project(":doc:manual") {
    ext {
        src = file("src")
        output = file("build/manual")
    }

    task compile << {
        new markdown2book.Generator(src, output, "UTF-8").generate()
    }

    task copyGroovyDoc(dependsOn: publishedGroovyModules.collect { project(it) }*.groovydoc) << {
        def groovyApi = new File(output, "groovy-api")
        if (!groovyApi.exists()) {
            assert groovyApi.mkdirs()
        }

        publishedGroovyModules.collect { module ->
            def baseName = module[module.lastIndexOf(":") + 1..module.size() - 1]
            copy {
                from project(module).groovydoc.destinationDir
                into new File(groovyApi, baseName)
            }
        }
    }

    task assemble(dependsOn: [compile, copyGroovyDoc], overwrite: true) {}
}

project(":doc:site") {
    ext {
        src = file("src")
        output = file("build/site")
        manualDir = file("$output/manual")
        thisManual = file("$manualDir/$project.version")
    }

    task clean(overwrite: true) << {
        if (output.exists()) {
            assert output.deleteDir()
        }
    }

    task includeManual(dependsOn: project(":doc:manual").assemble, type: Sync) {
        from project(":doc:manual").output
        into project.thisManual

        doLast {
            ant.symlink link: "${manualDir.path}/latest", resource: thisManual.path, overwrite: true
        }
    }

    task copySrc(type: Copy) {
        from src
        into output
    }

    task compile(dependsOn: [copySrc, includeManual]) {}

    task upload(dependsOn: compile) << {
        if (project.hasProperty('codehausUsername') && project.hasProperty('codehausPassword')) {
            def rep = new org.apache.maven.wagon.repository.Repository("codehaus", "https://dav.codehaus.org/groovy/modules/remote")
            def auth = new org.apache.maven.wagon.authentication.AuthenticationInfo()
            auth.userName = codehausUsername
            auth.password = codehausPassword
            def wagon = new org.apache.maven.wagon.providers.webdav.WebDavWagon()
            wagon.connect(rep, auth)

            output.eachFile {
                if (it.directory) {
                    wagon.putDirectory(it, it.name)
                } else {
                    wagon.put(it, it.name)
                }
            }
        } else {
            println "Can't upload site as credentials aren't set"
        }
    }

}